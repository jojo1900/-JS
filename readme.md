# 你不知道的 JS

## 作用域和闭包

### 词法作用域

- 编译(不重要)

  - JS 是一门编译语言（虽然没有编译中间产物和编译结果）
  - 编译的三个过程： 词法分析、语法分析、代码生成([AST 语法树](https://astexplorer.net/))

- 作用域是干啥的

  - 保障 JS 运行的三个部件：引擎(V8，负责整个程序的执行过程),编译器,作用域(变量)
  - 一个比喻(演习、警察、酒店)

- LHS 和 RHS 的区别

  - LHS:查找变量在哪: let a = 1
  - RHS:查找变量的值: console.log(a)

- 词法作用域:作用域与代码书写顺序有关。代码写好，运行之前，词法作用域就已经确定了。
- 欺骗词法作用域

  - eval(str):把 str 作为 js 代码执行
  - with(obj):如果在内部给 obj 上不存在的属性赋值，那么会赋值到全局

  ```js
  function foo(obj) {
    with (obj) {
      a = 1;
    }
  }

  var o = {
    b: 2,
  };

  foo(o);
  console.log(o.a); // undefined
  console.log(a); // 1
  ```

  - 最好不要用
    - JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。
    - 如果出现了eval(..) 或with，所有的优化可能都是无意义的


### 函数作用域和块作用域
- 函数作用域: 每个函数都有自己的作用域。
  - 为什么要这么设计：函数其实相当于向外部隐藏了自己的实现，和内部的作用域，根据最小暴露原则，作用域内的变量和函数等，最好只应该在使用的范围内可以查找和使用。如果全部暴露在全局作用域，那么很容易造成变量重名，性能下降等。
  - 一个缺点：函数作用域虽然隐藏了内部的标识符，但是自身的名字也会暴露出来。
    - 解决办法；立即执行函数。foo函数可以认为是一个函数表达式，函数表达式可以没有名字，并且长时间不用后会被垃圾回收。
   ```js
    (function foo(a) { 
        console.log(a)
    })(1)
   ```

      ```js
    (function foo(a) { 
        console.log(a)
    }(1))
   ```
- 块作用域:ES6之后，才加入了块作用域。用在for ,if 等代码块中。块作用域中，变量的生效范围仅在块中。相当于是在块内部声明一个变量。

  

### 作用域提升

### 作用域闭包

## this 和 对象原型

### this

### 对象

### 原型

### 类

### 行为委托
